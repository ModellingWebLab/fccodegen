//===========================================================================
// This source file was generated from CellML by chaste_codegen version {{converter_version}}
//
// Model: {{model_name}}
//
// Processed by chaste_codegen: https://github.com/ModellingWebLab/chaste-codegen
//     (translator: chaste_codegen, model type: {{model_type}})
// on {{generation_date}}
//
// <autogenerated>
//===========================================================================

//---------------------------------------------------------------------------
// Setup & input
//---------------------------------------------------------------------------

float64 Ynew[{{state_vars | length +1}}];
float64 dY[{{state_vars | length +1}}];
float64 Vmem;
float64 time;

// Parameters
{%- for param in modifiable_parameters %}
{{param["comment_name"]}} = {{param["initial_value"]}}; // [{{param["units"]}}]{%- endfor %}

// State variables
{%- for state_var in state_vars %}
float64 {{ state_var.var }} = Y[{{loop.index0}}]; // Units: {{state_var.units}}; Initial value: {{state_var.initial_value}}
{%- endfor %}
{%if free_variable.var_name !='time'%}float64 {%endif%}{{free_variable.var_name}} = Y[{{state_vars | length}}]; // Units: milliecond
        
//---------------------------------------------------------------------------
// Computation
//---------------------------------------------------------------------------
{%- for deriv in derivative_alpha_beta_eqs %}
{%- if deriv.is_piecewise%}

float64 {{deriv.lhs}}; // {{deriv.units}}
{%- for expr_conds in deriv.pw_expr_conds %}
{% if expr_conds[1] == 'true' or loop.index0 != 0%}else {% endif %}{% if expr_conds[1] != 'true'%}if ({{expr_conds[1]}}){%- endif %}
{{deriv.lhs}} = {{expr_conds[0]}}
{%- endfor %}
{% else %}
float64 {{deriv.lhs}} = {{deriv.rhs}}; // {{deriv.units}}
{%- endif %}
{%- endfor %}


// Update state vars
{%- for state_var in state_vars %}
Y[{{loop.index0}}] = {{ state_var.var }};
{%- endfor %}
Y[{{state_vars | length}}] = {{free_variable.var_name}};

//------------------------------------------------------------------------------
// Integration & Output
//------------------------------------------------------------------------------
// Rush-Larsen method

// get tau/inf or alpha/beta

{% for deriv in derivative_alpha_beta %}{% if deriv.type!='non_linear'%}float64 alphaOrTau_{{loop.index0}} = {{deriv.r_alpha_or_tau}};
float64 betaOrInf_{{loop.index0}} = {{deriv.r_beta_or_inf}};
{% endif %}{%- endfor %}
// gating variables: Exponential integration
{% for deriv in derivative_alpha_beta %}{%- if deriv.type=='inftau'%}
Ynew[{{loop.index0}}] = betaOrInf_{{loop.index0}} + (Y[{{loop.index0}}] - betaOrInf_{{loop.index0}})*exp(-dt/alphaOrTau_{{loop.index0}});
{%- elif deriv.type!='non_linear'%}
float64 tau_inv_{{loop.index0}} = alphaOrTau_{{loop.index0}} + betaOrInf_{{loop.index0}};
float64 y_inf_{{loop.index0}} = alphaOrTau_{{loop.index0}} / tau_inv_{{loop.index0}};
Ynew[{{loop.index0}}] = y_inf_{{loop.index0}} + (Y[{{loop.index0}}] - y_inf_{{loop.index0}})*exp(-dt*tau_inv_{{loop.index0}});
{%- endif %}
{%- endfor %}

// Remainder: Forward Euler
{% for deriv in derivative_alpha_beta %}
{%- if deriv.type=='non_linear'%}
Ynew[{{loop.index0}}] = Y[{{loop.index0}}] + dt * {{deriv.deriv}};{%- endif %}{%- endfor %}
Ynew[{{state_vars | length}}] = Y[{{state_vars | length}}] + dt;

Vmem = Ynew[0];
time = Ynew[{{state_vars | length}}];